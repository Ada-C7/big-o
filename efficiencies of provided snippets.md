1. O(n) —> With the ‘.each’ method, every element in the array will be visited once, making it a linear operation. (If the array size increases by 10 elements, it will take 10x longer to run ‘largerst?’).
2. O(n) —> Each ‘.each’ loop has an efficiency of O(n), as each element will be visited one time in each loop. Since the loops are not nested, the least efficient loop would define the Big O, but they are equally efficient in this case.
3. O(1) —> In ‘first_element_is_red?’ we are only accessing the first element in the array. Therefore as the array size increases, the computation time doesn't change, making the efficiency of this method constant regardless of the collection size. 
4. O(n^2) —> The method ‘duplicates?’ has two ‘.each’ loops, each with an efficiency of O(n). However since the loops are nested, their efficiencies are multiplied, resulting in a performance of O(n^2). Hence as the array gets larger, the computation time will increase exponentially. 
5. O(n*m)? —> The two loops do not depend on each other but both run linearly in time. (According to the Big O quiz provided, question 5, the efficiency would be exponential. Do you mind clarify this and explaining the correct answer?)
6. O(n) —> With the ‘.each’ method, every element will be visited once, meaning the time to perform the method ‘print_array’ will increase linearly with the array size.
7.  O(n^2) —> We learned that insertion sort has an efficiency of O(n^2). Looking at the code, there is a while loop nested inside of range iterator, meaning their efficiencies would be multiplied to give the Big(O). (What is the Big(O) of a while loop?)
8. O(n^2) —> We learned that selection sort has an efficiency of O(n^2). The code shows an ‘.upto’ loop nested inside of a ‘times’ loop. The Big(O) is the multiplication of these two loops complexities. 
